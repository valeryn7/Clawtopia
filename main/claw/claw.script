-- Tus constantes
local CELL_SIZE = 90
local GRID_COLS = 5
local CLAW_START_Y = 380
local CLAW_BOTTOM_Y = -150
local CLAW_SPEED = 400
local ROPE_LENGTH = 30
local MAX_ANGLE = math.rad(45)
local PENDULUM_SPEED = 2
local GRAB_OFFSET = 20 
local INPUT_MIN_Y = 0
local INPUT_MAX_Y = 1048

local function update_claw_rotation(self)
	self.current_angle = math.sin(self.time * PENDULUM_SPEED) * MAX_ANGLE
	go.set_rotation(vmath.quat_rotation_z(self.current_angle), "claw#claw_sprite")
end

local function calculate_strength(angle_deg)
	local min_strength = 0.2
	local max_strength = 1.0
	local clamped_angle = math.min(math.max(angle_deg, 0), 120)
	local normalized = clamped_angle / 120
	local curved = math.pow(normalized, 1.3) -- curva más progresiva
	return min_strength + curved * (max_strength - min_strength)
end

function init(self)
	local start_x = -((GRID_COLS - 1) * CELL_SIZE) / 2
	self.speed_multiplier = 1
	self.anchor_x = start_x + 2 * CELL_SIZE
	self.anchor_y = CLAW_START_Y
	self.time = 0
	self.pendulum_active = true
	self.loading = false
	self.load_amount = 0
	self.max_load = 1.0
	self.descending = false
	self.ascending = false
	self.total_drop = 0
	self.drop_progress = 0
	self.carrying_object = nil
	self.start_y = 0
	self.start_x = 0
	self.target_x = 0
	self.target_y = 0
	self.waiting_for_grab_response = false
	self.grab_response_timer = 0
	self.GRAB_RESPONSE_TIMEOUT = 0.2
	self.strength = 0.5
	self.captured_angle = math.rad(0)
	self.displayed_angle = 0
	self.target_charge_angle = 0
	self.smoothed_dy = 0
	self.state = "pendulum"
	
	msg.post(".", "acquire_input_focus")
	go.set_position(vmath.vector3(self.anchor_x, self.anchor_y, 6))
	update_claw_rotation(self)
end

function math.sign(x)
	return x > 0 and 1 or (x < 0 and -1 or 0)
end

function update(self, dt)
	dt = dt * self.speed_multiplier

	if self.pendulum_active then
		self.time = self.time + dt
		update_claw_rotation(self)
	end

	if self.loading then
		msg.post("charge_arrow#charge_bar", "set_manual_angle", { angle = self.target_charge_angle })
	end

	if self.waiting_for_grab_response then
		self.grab_response_timer = self.grab_response_timer + dt
		if self.grab_response_timer >= self.GRAB_RESPONSE_TIMEOUT then
			self.waiting_for_grab_response = false
			self.ascending = true
			self.descending = false
		end
	end

	if self.descending or self.ascending then
		local move = CLAW_SPEED * dt
		if self.descending then
			self.drop_progress = self.drop_progress + move
			local raw_t = math.min(self.drop_progress / self.total_drop, 1.0)
			local t = 1 - (1 - raw_t) * (1 - raw_t)
			self.anchor_x = self.start_x + (self.target_x - self.start_x) * t
			self.anchor_y = self.start_y + (self.target_y - self.start_y) * t

			if self.drop_progress >= self.total_drop then
				self.descending = false
				if self.total_drop < 10 then
					self.anchor_y = self.start_y
					self.anchor_x = self.start_x
					self.pendulum_active = true
					local ratio = math.max(-1, math.min(1, self.current_angle / MAX_ANGLE))
					self.time = math.asin(ratio) / PENDULUM_SPEED
				else
					local claw_pos = go.get_position()
					local claw_tip_y = go.get_position().y - ROPE_LENGTH - GRAB_OFFSET
					msg.post("grid_controller#grid", "grab_object_at_column", {
						x = claw_pos.x,
						y = claw_tip_y
					})
					msg.post("grid_controller#grid", "consume_drop")
					self.waiting_for_grab_response = true
					self.grab_response_timer = 0
				end
			end
		elseif self.ascending then
			self.drop_progress = self.drop_progress - move
			local raw_t = math.max(self.drop_progress / self.total_drop, 0)
			local t = raw_t * raw_t
			self.anchor_x = self.start_x + (self.target_x - self.start_x) * t
			self.anchor_y = self.start_y + (self.target_y - self.start_y) * t

			if self.drop_progress <= 0 then
				self.anchor_y = self.start_y
				self.anchor_x = self.start_x
				self.ascending = false
				self.pendulum_active = true
				local ratio = math.max(-1, math.min(1, self.current_angle / MAX_ANGLE))
				self.time = math.asin(ratio) / PENDULUM_SPEED
				if self.carrying_object then
					local pos = go.get_position(self.carrying_object)
					pos.z = 10

					-- Determinar animación
					local anim = (self.current_bear_color == "blue") and hash("explosion_blue") or hash("explosion_pink")

					-- Crear el puff y guardar su ID
					local puff = factory.create("#explosion_factory", pos)

					-- Mandar mensaje para elegir animación
					msg.post(puff, "play_explosion", { animation = anim })

					-- Escala opcional
					go.set_scale(vmath.vector3(1, 1, 1), puff)
					
					print(self.current_bear_color)
					-- Esperar un pequeño delay antes de eliminar el osito (para dejar ver la animación)
					timer.delay(0.1, false, function()
						if go.exists(self.carrying_object) then
							go.delete(self.carrying_object)
						end
						self.carrying_object = nil
					end)

-- 					timer.delay(0.2, false, function()
-- 						local pos = vmath.vector3(0, 100, 10)  -- Ajustá según el centro de tu pantalla
-- 						local victory_id = factory.create("#victory_layer_factory", pos)
-- 
-- 						-- Escalar el GO principal
-- 						go.set_scale(vmath.vector3(1, 1, 1), victory_id)
-- 
-- 						-- Forzar rotación normal
-- 						go.set_rotation(vmath.quat_rotation_z(0), victory_id)
-- 					end)
					
				end
			end
		end
		go.set_position(vmath.vector3(self.anchor_x, self.anchor_y, 6))
		if self.carrying_object then
			local offset_y = self.carrying_offset_y or 0
			local offset_x = self.carrying_offset_x or 0
			local pos = vmath.vector3(
				self.anchor_x + offset_x,
				self.anchor_y - ROPE_LENGTH - offset_y,
				4
			)
			go.set_position(pos, self.carrying_object)
		end
	end

	msg.post("stick", "set_bottom", { x = self.anchor_x, y = self.anchor_y - ROPE_LENGTH })
end

function on_input(self, action_id, action)
	if not self.activeTouch then
		return
	end

	if action.y > INPUT_MAX_Y then
		return
	end
	
	if action_id == hash("touch") or action_id == hash("mouse_button_1") or action_id == hash("space") then
		if action.pressed and self.pendulum_active then
			self.pendulum_active = false
			self.loading = true
			self.target_charge_angle = math.rad(1)
			self.displayed_angle = self.target_charge_angle
			msg.post("charge_arrow#charge_bar", "start_charge")
			msg.post("charge_arrow#charge_bar", "set_manual_angle", { angle = self.target_charge_angle })
		end

		if action.released and self.loading then
			self.loading = false
			msg.post("charge_arrow#charge_bar", "stop_charge")
		end
	end
end


function on_message(self, message_id, message)
	if message_id == hash("object_grabbed") then
		self.waiting_for_grab_response = false
		if message.object_sprite then
			self.carrying_offset_x = math.sin(self.current_angle) * 20  -- podés ajustar este 20
			self.carrying_offset_y = 25
			local pos = vmath.vector3(
			self.anchor_x + self.carrying_offset_x,
				self.anchor_y - ROPE_LENGTH - self.carrying_offset_y,
				2
			)
			self.carrying_object = factory.create("#object_factory", pos, nil, { sprite = hash(message.object_sprite) })
					
			if message.object_sprite == "bear_blue" then
				self.current_bear_color = "blue"
			else
				self.current_bear_color = "pink"
			end
			
			if self.carrying_object then
				go.set_scale(vmath.vector3(0.1, 0.1, 1), self.carrying_object)
				go.animate(self.carrying_object, "scale.x", go.PLAYBACK_ONCE_FORWARD, 0.8, go.EASING_OUTBACK, 0.3)
				go.animate(self.carrying_object, "scale.y", go.PLAYBACK_ONCE_FORWARD, 0.8, go.EASING_OUTBACK, 0.3)
			end
		end
		self.ascending = true
		self.descending = false
	elseif message_id == hash("set_charge_angle") then
		local angle_deg = math.min(math.deg(message.angle), 120)
		local strength = calculate_strength(angle_deg)
		print("Recibí ángulo:", angle_deg)
		print("Fuerza:", strength)

		self.start_y = self.anchor_y
		self.start_x = self.anchor_x

		local full_range = CELL_SIZE * 10
		local full_drop = strength * full_range
		self.total_drop = full_drop
		self.target_y = self.start_y - self.total_drop

		local offset_x = full_drop * math.sin(self.current_angle)
		local grid_half_width = ((GRID_COLS - 1) / 2) * CELL_SIZE
		self.target_x = math.max(-grid_half_width, math.min(grid_half_width, self.start_x + offset_x))
		self.drop_progress = 0
		self.descending = true

		print("Drop:", full_drop)
		print("Target Y:", self.target_y)
		print("Offset X:", offset_x)
	elseif message_id == hash("disable_touch") then
		self.activeTouch = false
	elseif message_id == hash("enable_touch") then
		self.activeTouch = true
	elseif message_id == hash("set_speed_multiplier") then
		self.speed_multiplier = message.value or 1
	end
end

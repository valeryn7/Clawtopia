-- Tus constantes
local CELL_SIZE = 90
local GRID_COLS = 5
local CLAW_START_Y = 380
local CLAW_BOTTOM_Y = -150
local CLAW_SPEED = 400
local ROPE_LENGTH = 30
local MAX_ANGLE = math.rad(45)
local PENDULUM_SPEED = 2
local GRAB_OFFSET = 20
local INPUT_MIN_Y = 150  -- mÃ­nimo Y donde sÃ­ se puede lanzar la garra
local INPUT_MAX_Y = 1048 -- mÃ¡ximo Y donde sÃ­ se puede lanzar la garra

local function update_claw_rotation(self)
	self.current_angle = math.sin(self.time * PENDULUM_SPEED) * MAX_ANGLE
	go.set_rotation(vmath.quat_rotation_z(self.current_angle), "claw#claw_sprite")
end

local function calculate_strength(angle_deg)
	local min_strength = 0.2  -- âœ… mÃ­nimo decente (baja algo)
	local max_strength = 1.0  -- mÃ¡ximo
	local clamped_angle = math.min(math.max(angle_deg, 0), 120)
	return min_strength + (clamped_angle / 120) * (max_strength - min_strength)
end

function init(self)
	local start_x = -((GRID_COLS - 1) * CELL_SIZE) / 2
	self.anchor_x = start_x + 2 * CELL_SIZE
	self.anchor_y = CLAW_START_Y

	self.time = 0
	self.pendulum_active = true
	self.loading = false
	self.load_amount = 0
	self.max_load = 1.0

	self.descending = false
	self.ascending = false
	self.total_drop = 0
	self.drop_progress = 0
	self.carrying_object = nil

	self.start_y = 0
	self.start_x = 0
	self.target_x = 0
	self.target_y = 0

	self.waiting_for_grab_response = false
	self.grab_response_timer = 0
	self.GRAB_RESPONSE_TIMEOUT = 0.2

	self.strength = 0.5

	self.activeTouch = true
	self.captured_angle = math.rad(0)
	self.displayed_angle = 0
	self.target_charge_angle = 0
	self.smoothed_dy = 0

	msg.post(".", "acquire_input_focus")
	go.set_position(vmath.vector3(self.anchor_x, self.anchor_y, 6))
	update_claw_rotation(self)
end

function math.sign(x)
	return x > 0 and 1 or (x < 0 and -1 or 0)
end

function update(self, dt)
	if self.pendulum_active then
		self.time = self.time + dt
		update_claw_rotation(self)
	end

	-- Interpolar Ã¡ngulo de carga suavemente
	if self.loading then
		msg.post("charge_arrow#charge_bar", "set_manual_angle", { angle = self.target_charge_angle })
	end
	
	
	if self.waiting_for_grab_response then
		self.grab_response_timer = self.grab_response_timer + dt
		if self.grab_response_timer >= self.GRAB_RESPONSE_TIMEOUT then
			self.waiting_for_grab_response = false
			self.ascending = true
			self.descending = false
		end
	end

	if self.descending or self.ascending then
		local move = CLAW_SPEED * dt

		if self.descending then
			self.drop_progress = self.drop_progress + move
			local raw_t = math.min(self.drop_progress / self.total_drop, 1.0)
			local t = 1 - (1 - raw_t) * (1 - raw_t)  -- EASING OUT

			self.anchor_x = self.start_x + (self.target_x - self.start_x) * t
			self.anchor_y = self.start_y + (self.target_y - self.start_y) * t

			if self.drop_progress >= self.total_drop then
				self.descending = false

				if self.total_drop < 10 then
					self.anchor_y = self.start_y
					self.anchor_x = self.start_x
					self.pendulum_active = true
					local ratio = math.max(-1, math.min(1, self.current_angle / MAX_ANGLE))
					self.time = math.asin(ratio) / PENDULUM_SPEED
				else
					msg.post("grid_controller#grid", "consume_drop")
					local claw_pos = go.get_position()
					local claw_tip_y = go.get_position().y - ROPE_LENGTH - GRAB_OFFSET
					
					msg.post("grid_controller#grid", "grab_object_at_column", {
						x = claw_pos.x,
						y = claw_tip_y
					})

					self.waiting_for_grab_response = true
					self.grab_response_timer = 0
				end
			end

		elseif self.ascending then
			self.drop_progress = self.drop_progress - move
			local raw_t = math.max(self.drop_progress / self.total_drop, 0)
			local t = raw_t * raw_t  -- EASING IN

			self.anchor_x = self.start_x + (self.target_x - self.start_x) * t
			self.anchor_y = self.start_y + (self.target_y - self.start_y) * t

			if self.drop_progress <= 0 then
				self.anchor_y = self.start_y
				self.anchor_x = self.start_x
				self.ascending = false
				self.pendulum_active = true

				local ratio = math.max(-1, math.min(1, self.current_angle / MAX_ANGLE))
				self.time = math.asin(ratio) / PENDULUM_SPEED

				if self.carrying_object then
					go.delete(self.carrying_object)
					self.carrying_object = nil
				end
			end
		end

		go.set_position(vmath.vector3(self.anchor_x, self.anchor_y, 6))

		if self.carrying_object then
			local pos = vmath.vector3(self.anchor_x, self.anchor_y - ROPE_LENGTH, 4)
			go.set_position(pos, self.carrying_object)
		end
	end

	msg.post("stick", "set_bottom", { x = self.anchor_x, y = self.anchor_y - ROPE_LENGTH })
end

function on_input(self, action_id, action)
	if not self.activeTouch then return end
	if action.y < INPUT_MIN_Y or action.y > INPUT_MAX_Y then return end

	local is_pc = not sys.get_sys_info().device_model
	local is_mobile = sys.get_sys_info().device_model
	local valid_touch = (action_id == hash("touch") and is_mobile) or
	(action_id == hash("mouse_button_1") and is_pc) or
	(action_id == hash("space") and is_pc)

	-- PRESIONAR
	if valid_touch and action.pressed then
		if self.pendulum_active then
			self.pendulum_active = false
			self.loading = true
			self.start_touch_y = action.y

			local initial_angle = math.rad(1)
			self.target_charge_angle = initial_angle
			self.displayed_angle = initial_angle
			msg.post("charge_arrow#charge_bar", "start_charge")
			msg.post("charge_arrow#charge_bar", "set_manual_angle", { angle = initial_angle }) -- ðŸ‘ˆ esto lo activa desde el primer frame
		end
	end
	

	-- MOVER MIENTRAS PRESIONA (incluso si movÃ©s muy rÃ¡pido)
	if self.loading and (action.pressed or action.repeated or action.down) then
		local dy = math.max(self.start_touch_y - action.y, 0)
		local percentage = math.min(dy / 160, 1)
		self.target_charge_angle = math.rad(percentage * 150)
		-- No tocar displayed_angle acÃ¡, dejamos que update() lo interpole
		
	end

	-- SOLTAR
	if valid_touch and action.released and self.loading then
		self.loading = false
		msg.post("charge_arrow#charge_bar", "stop_charge")

		local angle_deg = math.deg(self.target_charge_angle)
		local strength = calculate_strength(angle_deg)

		self.start_y = self.anchor_y
		self.start_x = self.anchor_x

		local full_range = CELL_SIZE * 8
		local full_drop = strength * full_range
		self.total_drop = full_drop
		self.target_y = self.start_y - self.total_drop

		local offset_x = full_drop * math.sin(self.current_angle)
		local grid_half_width = ((GRID_COLS - 1) / 2) * CELL_SIZE
		self.target_x = math.max(-grid_half_width, math.min(grid_half_width, self.start_x + offset_x))

		self.drop_progress = 0
		self.descending = true
	end
end


function on_message(self, message_id, message)
	if message_id == hash("object_grabbed") then
		self.waiting_for_grab_response = false

		if message.object_sprite then
			self.carrying_object = factory.create("#object_factory", vmath.vector3(self.anchor_x, self.anchor_y - ROPE_LENGTH, 2), nil, { sprite = hash(message.object_sprite) })
			if self.carrying_object then
				go.set_scale(vmath.vector3(0.1, 0.1, 1), self.carrying_object)
				go.animate(self.carrying_object, "scale.x", go.PLAYBACK_ONCE_FORWARD, 0.8, go.EASING_OUTBACK, 0.3)
				go.animate(self.carrying_object, "scale.y", go.PLAYBACK_ONCE_FORWARD, 0.8, go.EASING_OUTBACK, 0.3)
			end
		end

		self.ascending = true
		self.descending = false

	elseif message_id == hash("set_charge_angle") then
		local angle_deg = math.deg(message.angle)
		self.strength = calculate_strength(angle_deg)
		print("RecibÃ­ Ã¡ngulo:", angle_deg, "-> Fuerza:", self.strength)

	elseif message_id == hash("disable_touch") then
		self.activeTouch = false

	elseif message_id == hash("enable_touch") then
		self.activeTouch = true
	end
end

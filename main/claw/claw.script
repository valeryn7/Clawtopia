-- Tus constantes
local CELL_SIZE = 90
local GRID_COLS = 5
local CLAW_START_Y = 380
local CLAW_BOTTOM_Y = -150
local CLAW_SPEED = 400
local ROPE_LENGTH = 30
local MAX_ANGLE = math.rad(45)
local PENDULUM_SPEED = 2
local INPUT_MIN_Y = 150  -- mÃ­nimo Y donde sÃ­ se puede lanzar la garra
local INPUT_MAX_Y = 1048 -- mÃ¡ximo Y donde sÃ­ se puede lanzar la garra

local function update_claw_rotation(self)
	self.current_angle = math.sin(self.time * PENDULUM_SPEED) * MAX_ANGLE
	go.set_rotation(vmath.quat_rotation_z(self.current_angle), "claw#claw_sprite")
end

local function calculate_strength(angle_deg)
	if angle_deg >= 0 and angle_deg < 40 then
		return 0.5
	elseif angle_deg >= 40 and angle_deg < 50 then
		return 0.75
	elseif angle_deg >= 60 and angle_deg < 110 then
		return 0.75
	elseif angle_deg >= 110 and angle_deg < 120 then
		return 0.8
	elseif angle_deg >= 120 then
		return 1.0
	else
		return 0.5
	end
end

function init(self)
	local start_x = -((GRID_COLS - 1) * CELL_SIZE) / 2
	self.anchor_x = start_x + 2 * CELL_SIZE
	self.anchor_y = CLAW_START_Y

	self.time = 0
	self.pendulum_active = true
	self.loading = false
	self.load_amount = 0
	self.max_load = 1.0

	self.descending = false
	self.ascending = false
	self.total_drop = 0
	self.drop_progress = 0
	self.carrying_object = nil

	self.start_y = 0
	self.start_x = 0
	self.target_x = 0
	self.target_y = 0
	self.captured_angle = 0

	self.waiting_for_grab_response = false
	self.grab_response_timer = 0
	self.GRAB_RESPONSE_TIMEOUT = 0.2

	self.strength = 0.5

	self.activeTouch = true

	msg.post(".", "acquire_input_focus")
	go.set_position(vmath.vector3(self.anchor_x, self.anchor_y, 3))
	update_claw_rotation(self)
end

function update(self, dt)
	if self.pendulum_active then
		self.time = self.time + dt
		update_claw_rotation(self)
	end

	if self.loading then
		self.load_amount = math.min(self.load_amount + dt, self.max_load)
	end

	if self.waiting_for_grab_response then
		self.grab_response_timer = self.grab_response_timer + dt
		if self.grab_response_timer >= self.GRAB_RESPONSE_TIMEOUT then
			self.waiting_for_grab_response = false
			self.ascending = true
			self.descending = false
		end
	end

	if self.descending or self.ascending then
		local move = CLAW_SPEED * dt

		if self.descending then
			self.drop_progress = self.drop_progress + move
			local raw_t = math.min(self.drop_progress / self.total_drop, 1.0)
			local t = 1 - (1 - raw_t) * (1 - raw_t)  -- EASING OUT

			self.anchor_x = self.start_x + (self.target_x - self.start_x) * t
			self.anchor_y = self.start_y + (self.target_y - self.start_y) * t

			if self.drop_progress >= self.total_drop then
				self.descending = false

				if self.total_drop < 10 then
					-- Demasiado corto, vuelve al columpio
					self.anchor_y = self.start_y
					self.anchor_x = self.start_x
					self.pendulum_active = true
					local ratio = math.max(-1, math.min(1, self.captured_angle / MAX_ANGLE))
					self.time = math.asin(ratio) / PENDULUM_SPEED
				else
					msg.post("grid_controller#grid", "consume_drop")
					msg.post("grid_controller#grid", "grab_object_at_column", {
						x = self.anchor_x,
						y = self.anchor_y - ROPE_LENGTH
					})

					self.waiting_for_grab_response = true
					self.grab_response_timer = 0
				end
			end
			

		elseif self.ascending then
			self.drop_progress = self.drop_progress - move
			local raw_t = math.max(self.drop_progress / self.total_drop, 0)
			local t = raw_t * raw_t  -- EASING IN

			self.anchor_x = self.start_x + (self.target_x - self.start_x) * t
			self.anchor_y = self.start_y + (self.target_y - self.start_y) * t

			if self.drop_progress <= 0 then
				self.anchor_y = self.start_y
				self.anchor_x = self.start_x
				self.ascending = false
				self.pendulum_active = true

				local ratio = math.max(-1, math.min(1, self.captured_angle / MAX_ANGLE))
				self.time = math.asin(ratio) / PENDULUM_SPEED

				if self.carrying_object then
					go.delete(self.carrying_object)
					self.carrying_object = nil
				end
			end
		end

		go.set_position(vmath.vector3(self.anchor_x, self.anchor_y, 3))

		if self.carrying_object then
			local pos = vmath.vector3(self.anchor_x, self.anchor_y - ROPE_LENGTH, 2)
			go.set_position(pos, self.carrying_object)
		end
	end

	msg.post("stick", "set_bottom", { x = self.anchor_x, y = self.anchor_y - ROPE_LENGTH })
end


function on_input(self, action_id, action)
	if not self.activeTouch then
		return
	end

	if action.y < INPUT_MIN_Y or action.y > INPUT_MAX_Y then
		return
	end
	
	local is_pc = not sys.get_sys_info().device_model
	local is_mobile = sys.get_sys_info().device_model

	if action.pressed then
		if (action_id == hash("space") and is_pc) or (action_id == hash("touch") and is_mobile) then
			if self.pendulum_active then
				self.pendulum_active = false
				self.loading = true
				self.load_amount = 0

				msg.post("charge_arrow#charge_bar", "start_charge")
			end
		end
	end

	if action.released and self.loading then
		self.loading = false

		msg.post("charge_arrow#charge_bar", "stop_charge")

		self.start_y = self.anchor_y
		self.start_x = self.anchor_x

		self.captured_angle = self.current_angle

		local strength = self.load_amount / self.max_load
		if self.load_amount >= 1.0 then
			strength = 1.2
		end

		local full_range = CELL_SIZE * 6
		local full_drop = strength * full_range

		local raw_drop_y = full_drop * math.cos(self.captured_angle)
		local offset_x = full_drop * math.sin(self.captured_angle)

		-- ðŸ”§ Alinear al centro de la celda mÃ¡s cercana
		local rows = math.floor(raw_drop_y / CELL_SIZE + 0.5)
		self.total_drop = rows * CELL_SIZE
		self.target_y = self.start_y - self.total_drop
		
		-- ðŸ”§ Limitar desplazamiento horizontal al borde del grid
		local grid_half_width = ((GRID_COLS - 1) / 2) * CELL_SIZE
		self.target_x = self.start_x + offset_x
		self.target_x = math.max(-grid_half_width, math.min(grid_half_width, self.target_x))

		self.drop_progress = 0
		self.descending = true
	end
end

function on_message(self, message_id, message)
	if message_id == hash("object_grabbed") then
		self.waiting_for_grab_response = false

		if message.object_sprite then
			self.carrying_object = factory.create("#object_factory", vmath.vector3(self.anchor_x, self.anchor_y - ROPE_LENGTH, 2), nil, { sprite = hash(message.object_sprite) })
			if self.carrying_object then
				go.set_scale(vmath.vector3(0.1, 0.1, 1), self.carrying_object)
				go.animate(self.carrying_object, "scale.x", go.PLAYBACK_ONCE_FORWARD, 0.8, go.EASING_OUTBACK, 0.3)
				go.animate(self.carrying_object, "scale.y", go.PLAYBACK_ONCE_FORWARD, 0.8, go.EASING_OUTBACK, 0.3)
			end
		end

		self.ascending = true
		self.descending = false

	elseif message_id == hash("set_charge_angle") then
		local angle_deg = math.deg(message.angle)
		self.strength = calculate_strength(angle_deg)
		print("RecibÃ­ Ã¡ngulo:", angle_deg, "-> Fuerza:", self.strength)

	elseif message_id == hash("disable_touch") then
		self.activeTouch = false

	elseif message_id == hash("enable_touch") then
		self.activeTouch = true
	end
end

-- Tus constantes
local CELL_SIZE = 90
local GRID_COLS = 5
local CLAW_START_Y = 300
local CLAW_BOTTOM_Y = -150
local CLAW_SPEED = 400
local ROPE_LENGTH = 40
local MAX_ANGLE = math.rad(45)
local PENDULUM_SPEED = 2

local function update_claw_rotation(self)
	self.current_angle = math.sin(self.time * PENDULUM_SPEED) * MAX_ANGLE
	go.set_rotation(vmath.quat_rotation_z(self.current_angle), "claw#claw_sprite")
end

local function calculate_strength(angle_deg)
	if angle_deg >= 0 and angle_deg < 40 then
		return 0.5
	elseif angle_deg >= 40 and angle_deg < 50 then
		return 0.75
	elseif angle_deg >= 60 and angle_deg < 110 then
		return 0.75
	elseif angle_deg >= 110 and angle_deg < 120 then
		return 0.8
	elseif angle_deg >= 120 then
		return 1.0
	else
		return 0.5
	end
end

function init(self)
	local start_x = -((GRID_COLS - 1) * CELL_SIZE) / 2
	self.anchor_x = start_x + 2 * CELL_SIZE
	self.anchor_y = CLAW_START_Y

	self.time = 0
	self.pendulum_active = true
	self.loading = false
	self.load_amount = 0
	self.max_load = 1.0

	self.descending = false
	self.ascending = false
	self.total_drop = 0
	self.drop_progress = 0
	self.carrying_object = nil

	self.start_y = 0
	self.start_x = 0
	self.target_x = 0
	self.target_y = 0
	self.captured_angle = 0

	self.waiting_for_grab_response = false
	self.grab_response_timer = 0
	self.GRAB_RESPONSE_TIMEOUT = 0.2

	self.strength = 0.5

	self.activeTouch = true

	msg.post(".", "acquire_input_focus")
	go.set_position(vmath.vector3(self.anchor_x, self.anchor_y, 3))
	update_claw_rotation(self)
	
	--msg.post("charge_bar_arrow#sprite", "disable")
	--msg.post("charge_bar#sprite", "disable")
end

function update(self, dt)
	if self.pendulum_active then
		self.time = self.time + dt
		update_claw_rotation(self)
	end

	if self.loading then
		self.load_amount = math.min(self.load_amount + dt, self.max_load)
	end

	if self.waiting_for_grab_response then
		self.grab_response_timer = self.grab_response_timer + dt
		if self.grab_response_timer >= self.GRAB_RESPONSE_TIMEOUT then
			self.waiting_for_grab_response = false
			self.ascending = true
			self.descending = false
		end
	end

	if self.descending or self.ascending then
		local move = CLAW_SPEED * dt

		if self.descending then
			self.drop_progress = self.drop_progress + move
			local t = math.min(self.drop_progress / self.total_drop, 1.0)

			self.anchor_x = self.start_x + (self.target_x - self.start_x) * t
			self.anchor_y = self.start_y + (self.target_y - self.start_y) * t

			if self.drop_progress >= self.total_drop then
				self.descending = false

				if self.total_drop < 10 then
					-- 游대 No baj칩 casi nada, no hacer nada
					self.anchor_y = self.start_y
					self.anchor_x = self.start_x
					self.pendulum_active = true

					local ratio = math.max(-1, math.min(1, self.captured_angle / MAX_ANGLE))
					self.time = math.asin(ratio) / PENDULUM_SPEED
				else
					msg.post("grid_controller#grid", "consume_drop")

					msg.post("grid_controller#grid", "grab_object_at_column", {
						x = self.anchor_x,
						y = self.anchor_y - ROPE_LENGTH
					})

					self.waiting_for_grab_response = true
					self.grab_response_timer = 0
				end
			end

		elseif self.ascending then
			self.drop_progress = self.drop_progress - move
			local t = math.max(self.drop_progress / self.total_drop, 0)

			self.anchor_x = self.start_x + (self.target_x - self.start_x) * t
			self.anchor_y = self.start_y + (self.target_y - self.start_y) * t

			if self.drop_progress <= 0 then
				self.anchor_y = self.start_y
				self.anchor_x = self.start_x
				self.ascending = false
				self.pendulum_active = true

				local ratio = math.max(-1, math.min(1, self.captured_angle / MAX_ANGLE))
				self.time = math.asin(ratio) / PENDULUM_SPEED

				if self.carrying_object then
					go.delete(self.carrying_object)
					self.carrying_object = nil
				end
			end
		end

		go.set_position(vmath.vector3(self.anchor_x, self.anchor_y, 3))

		if self.carrying_object then
			local pos = vmath.vector3(self.anchor_x, self.anchor_y - ROPE_LENGTH - 40, 2)
			go.set_position(pos, self.carrying_object)
		end
	end

	msg.post("stick", "set_bottom", { x = self.anchor_x, y = self.anchor_y - ROPE_LENGTH })
end

function on_input(self, action_id, action)
	if (self.activeTouch) then
		local is_pc = not sys.get_sys_info().device_model
		local is_mobile = sys.get_sys_info().device_model

		if action.pressed then
			if (action_id == hash("space") and is_pc) or (action_id == hash("touch") and is_mobile) then
				if self.pendulum_active then
					self.pendulum_active = false
					self.loading = true
					self.load_amount = 0

					msg.post("charge_arrow#charge_bar", "start_charge")
				end
			end
		end

		if action.released and self.loading then
			self.loading = false

			msg.post("charge_arrow#charge_bar", "stop_charge")

			self.start_y = self.anchor_y
			self.start_x = self.anchor_x

			self.captured_angle = self.current_angle

			local strength = self.load_amount / self.max_load
			if self.load_amount >= 1.0 then
				strength = 1.2
			end

			local full_range = CELL_SIZE * 6
			local full_drop = strength * full_range

			local raw_drop_y = full_drop * math.cos(self.captured_angle)
			local offset_x = full_drop * math.sin(self.captured_angle)

			-- 游댢 Alinear al centro de la celda m치s cercana
			local rows = math.floor(raw_drop_y / CELL_SIZE + 0.5)
			self.total_drop = rows * CELL_SIZE
			self.target_y = self.start_y - self.total_drop + (CELL_SIZE / 2)

			-- 游댢 Limitar desplazamiento horizontal al borde del grid
			local grid_half_width = ((GRID_COLS - 1) / 2) * CELL_SIZE
			self.target_x = self.start_x + offset_x
			self.target_x = math.max(-grid_half_width, math.min(grid_half_width, self.target_x))

			self.drop_progress = 0
			self.descending = true
		end
	end
end

function on_message(self, message_id, message)
	if message_id == hash("object_grabbed") then
		self.waiting_for_grab_response = false

		if message.object_sprite then
			self.carrying_object = factory.create("#object_factory", vmath.vector3(self.anchor_x, self.anchor_y - ROPE_LENGTH, 2), nil, { sprite = hash(message.object_sprite) })
			if self.carrying_object then
				go.set_scale(vmath.vector3(0.1, 0.1, 1), self.carrying_object)
				go.animate(self.carrying_object, "scale.x", go.PLAYBACK_ONCE_FORWARD, 0.8, go.EASING_OUTBACK, 0.3)
				go.animate(self.carrying_object, "scale.y", go.PLAYBACK_ONCE_FORWARD, 0.8, go.EASING_OUTBACK, 0.3)
			end
		end

		self.ascending = true
		self.descending = false

	elseif message_id == hash("set_charge_angle") then
		local angle_deg = math.deg(message.angle)
		self.strength = calculate_strength(angle_deg)
		print("Recib칤 치ngulo:", angle_deg, "-> Fuerza:", self.strength)

	elseif message_id == hash("disable_touch") then
		self.activeTouch = false

	elseif message_id == hash("enable_touch") then
		self.activeTouch = true
	end
end

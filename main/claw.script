-- Tus constantes
local CELL_SIZE = 90
local GRID_COLS = 5
local CLAW_START_Y = 300
local CLAW_BOTTOM_Y = 0
local CLAW_SPEED = 400
local ROPE_LENGTH = 40
local MAX_ANGLE = math.rad(30)
local PENDULUM_SPEED = 2

local function update_claw_rotation(self)
	self.current_angle = math.sin(self.time * PENDULUM_SPEED) * MAX_ANGLE
	go.set_rotation(vmath.quat_rotation_z(self.current_angle), "claw#claw_sprite")
end

local function calculate_strength(angle_deg)
	if angle_deg >= 0 and angle_deg < 40 then
		return 0.5 -- fuerza baja (amarillo)
	elseif angle_deg >= 40 and angle_deg < 80 then
		return 0.75 -- fuerza media (naranja)
	elseif angle_deg >= 80 and angle_deg <= 120 then
		return 1.0 -- fuerza alta (rojo)
	else
		return 0.5 -- seguridad
	end
end

function init(self)
	local start_x = -((GRID_COLS - 1) * CELL_SIZE) / 2
	self.anchor_x = start_x + 2 * CELL_SIZE
	self.anchor_y = CLAW_START_Y

	self.time = 0
	self.pendulum_active = true
	self.loading = false
	self.load_amount = 0
	self.max_load = 1.0

	self.descending = false
	self.ascending = false
	self.total_drop = 0
	self.drop_progress = 0
	self.carrying_object = nil

	self.start_y = 0
	self.start_x = 0
	self.captured_angle = 0

	self.waiting_for_grab_response = false
	self.grab_response_timer = 0
	self.GRAB_RESPONSE_TIMEOUT = 0.2 -- seconds

	self.strength = 0.5 -- fuerza por defecto

	msg.post(".", "acquire_input_focus")
	go.set_position(vmath.vector3(self.anchor_x, self.anchor_y, 3))
	update_claw_rotation(self)

	-- ğŸ”¥ Al arrancar, ocultar el arco y la flecha
	msg.post("color_arc#sprite", "disable")
	msg.post("charge_bar#sprite", "disable")
end

function update(self, dt)
	if self.pendulum_active then
		self.time = self.time + dt
		update_claw_rotation(self)
	end

	if self.loading then
		self.load_amount = math.min(self.load_amount + dt, self.max_load)
	end

	if self.waiting_for_grab_response then
		self.grab_response_timer = self.grab_response_timer + dt
		if self.grab_response_timer >= self.GRAB_RESPONSE_TIMEOUT then
			self.waiting_for_grab_response = false
			self.ascending = true
			self.descending = false
		end
	end

	if self.descending or self.ascending then
		local move = CLAW_SPEED * dt

		if self.descending then
			self.drop_progress = self.drop_progress + move
			local target_y = self.start_y - self.drop_progress

			self.anchor_y = target_y
			self.anchor_x = self.start_x + math.tan(self.captured_angle) * (self.start_y - self.anchor_y)

			if self.drop_progress >= self.total_drop then
				self.drop_progress = self.total_drop
				self.descending = false
				msg.post("/grid_controller#grid", "grab_object_at_column", { x = self.anchor_x, y = self.anchor_y - ROPE_LENGTH })
				self.waiting_for_grab_response = true
				self.grab_response_timer = 0
			end
		elseif self.ascending then
			self.anchor_y = self.anchor_y + move
			self.anchor_x = self.start_x + math.tan(self.captured_angle) * (self.start_y - self.anchor_y)

			if self.anchor_y >= self.start_y then
				self.anchor_y = self.start_y
				self.anchor_x = self.start_x
				self.ascending = false
				self.pendulum_active = true

				local ratio = math.max(-1, math.min(1, self.captured_angle / MAX_ANGLE))
				self.time = math.asin(ratio) / PENDULUM_SPEED

				if self.carrying_object then
					go.delete(self.carrying_object)
					self.carrying_object = nil
				end
			end
		end

		go.set_position(vmath.vector3(self.anchor_x, self.anchor_y, 3))

		if self.carrying_object then
			local pos = vmath.vector3(self.anchor_x, self.anchor_y - ROPE_LENGTH - 40, 2)
			go.set_position(pos, self.carrying_object)
		end
	end

	msg.post("stick", "set_bottom", { x = self.anchor_x, y = self.anchor_y - ROPE_LENGTH })
end

function on_input(self, action_id, action)
	if action_id == hash("space") or action_id == hash("touch") or action_id == hash("click")) and action.pressed then
		if action.pressed then
			if action_id == hash("space") and not sys.get_sys_info().device_model then
				-- PC: Tecla space
				if self.pendulum_active then
					self.pendulum_active = false
					self.loading = true
					self.load_amount = 0

					msg.post("charge_bar", "start_charge")
					msg.post("color_arc#sprite", "enable")
					msg.post("charge_bar#sprite", "enable")
				end
			elseif action_id == hash("touch") and sys.get_sys_info().device_model then
				-- Mobile: Touch
				if self.pendulum_active then
					self.pendulum_active = false
					self.loading = true
					self.load_amount = 0

					msg.post("charge_bar", "start_charge")
					msg.post("color_arc#sprite", "enable")
					msg.post("charge_bar#sprite", "enable")
				end
			end
		elseif action.released then
			if self.loading then
				self.loading = false

				-- ğŸ”¥ Paramos la carga
				msg.post("charge_bar", "stop_charge")
				msg.post("color_arc#sprite", "disable")
				msg.post("charge_bar#sprite", "disable")

				self.start_y = self.anchor_y
				self.start_x = self.anchor_x

				self.total_drop = (self.load_amount / self.max_load) * (self.start_y - CLAW_BOTTOM_Y)

				if self.load_amount >= 1.0 then
					self.total_drop = self.total_drop + 200
				end

				self.drop_progress = 0
				self.descending = true
				self.captured_angle = self.current_angle
			end
		end
	end
end

function on_message(self, message_id, message)
	if message_id == hash("object_grabbed") then
		self.waiting_for_grab_response = false

		if message.object_sprite then
			self.carrying_object = factory.create("#object_factory", vmath.vector3(self.anchor_x, self.anchor_y - ROPE_LENGTH, 2), nil, { sprite = hash(message.object_sprite) })
			if self.carrying_object then
				go.set_scale(vmath.vector3(0.1, 0.1, 1), self.carrying_object)
				go.animate(self.carrying_object, "scale.x", go.PLAYBACK_ONCE_FORWARD, 0.8, go.EASING_OUTBACK, 0.3)
				go.animate(self.carrying_object, "scale.y", go.PLAYBACK_ONCE_FORWARD, 0.8, go.EASING_OUTBACK, 0.3)
			end
		end

		self.ascending = true
		self.descending = false

	elseif message_id == hash("set_charge_angle") then
		local angle_deg = math.deg(message.angle)
		self.strength = calculate_strength(angle_deg)
		print("RecibÃ­ Ã¡ngulo:", angle_deg, "-> Fuerza:", self.strength)
	end
end

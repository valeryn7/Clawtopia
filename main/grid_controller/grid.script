local CELL_SIZE = 100
local GRID_COLS = 5
local GRID_ROWS = 6

go.property("level", 1)

local POINTS = {
	bear_golden = 30,
	bear_blue = 15,
	bear_pink = 15,
	candy = 10,
	ball = 5,
	flip_flop = 5,
	box = 25,
	bomb = 0,
	bug = 0
}

local LEVELS = require("main.levels.levels")

local function explode_adjacent_cells(self, row, col)
	local directions = {
		{ d_row = -1, d_col = 0 }, { d_row = 1, d_col = 0 },
		{ d_row = 0, d_col = -1 }, { d_row = 0, d_col = 1 }
	}
	for _, dir in ipairs(directions) do
		local r, c = row + dir.d_row, col + dir.d_col
		if r >= 0 and r < GRID_ROWS and c >= 0 and c < GRID_COLS then
			local neighbor = self.grid[r][c]
			if neighbor and not neighbor.captured then
				msg.post(neighbor.id, "explode")
				neighbor.captured = true
			end
		end
	end
end

local function check_impossible_goals(self)
	local remaining = {}
	for row = 0, GRID_ROWS - 1 do
		for col = 0, GRID_COLS - 1 do
			local cell = self.grid[row][col]
			if cell and not cell.captured then
				local t = cell.sprite
				if POINTS[t] and POINTS[t] > 0 then
					remaining[t] = (remaining[t] or 0) + 1
				end
			end
		end
	end
	for _, goal in ipairs(self.goals) do
		if (remaining[goal.type] or 0) < (goal.required - goal.collected) then
			return true
		end
	end
	return false
end

local function generate_goals_from_level(self)
	local data = LEVELS[self.level]
	self.goals = {}
	for _, g in ipairs(data.goals) do
		table.insert(self.goals, {
			type = g.type,
			required = g.required,
			collected = 0,
			points_total = g.required * POINTS[g.type]
		})
	end
	msg.post("hud", "init_goals", { goals = self.goals })
end

local function reset_grid(self)
	if self.creating_grid then
		print("‚è≥ Ya se est√° creando la grilla, ignorando este llamado")
		return
	end
	self.creating_grid = true

	for row = 0, GRID_ROWS - 1 do
		for col = 0, GRID_COLS - 1 do
			local cell = self.grid[row] and self.grid[row][col]
			if cell and cell.id and go.exists(cell.id) then
				msg.post(cell.id, "stop_particles")
				go.delete(cell.id)
			end
		end
	end

	self.grid = {}
	self.total_cells = 0

	timer.delay(0.05, false, function()
		local level_data = LEVELS[self.level]
		local layout = level_data and level_data.grid or {}
		local locked_cells = level_data.locked_cells or {}

		local start_x = -((GRID_COLS - 1) * CELL_SIZE) / 2
		local total_grid_height = CELL_SIZE * GRID_ROWS
		local start_y = (1280 / 2) - ((1280 - total_grid_height) / 2) - 100

		self.remaining_drops = level_data.max_drops or 5
		msg.post("drops#drops", "set_drops", { drops = self.remaining_drops })

		for row = 0, GRID_ROWS - 1 do
			self.grid[row] = {}
			for col = 0, GRID_COLS - 1 do
				local x = start_x + col * CELL_SIZE
				local y = start_y - row * CELL_SIZE
				local sprite_name = layout[row + 1] and layout[row + 1][col + 1]
				if sprite_name and sprite_name ~= "" then
					local id = factory.create("#cell_factory", vmath.vector3(x, y, 1))
					if id then
						local locked = false
						local lock_color = nil
						for _, lock in ipairs(locked_cells) do
							if lock.row == row + 1 and lock.col == col + 1 then
								locked = true
								lock_color = lock.color
								break
							end
						end
						
						self.grid[row][col] = {
							id = id,
							sprite = sprite_name,
							locked = locked,
							lock_color = lock_color,
							revealed = true,
							captured = false,
							x = x,
							y = y
						}
						self.total_cells = self.total_cells + 1
						msg.post(id, "set_revealed_sprite", { sprite = sprite_name, row = row, col = col })
						if locked then
							msg.post(id, "set_locked", { color = lock_color })
						end
						msg.post(id, "reveal")
					end
				end
			end
		end

		self.creating_grid = false
	end)
end

function init(self)
	self.grid = {}
	self.multiplier = 1
	self.total_points = 0
	self.game_over = false
	self.creating_grid = false
	self.collected_keys = {}
end

function on_message(self, message_id, message, sender)
	if message_id == hash("grab_object_at_column") then
		local x, y = message.x, message.y
		local start_x = -((GRID_COLS - 1) * CELL_SIZE) / 2
		local col = math.floor((x - start_x + CELL_SIZE/2) / CELL_SIZE)

		if col >= 0 and col < GRID_COLS then
			for row = 0, GRID_ROWS - 1 do
				local cell = self.grid[row][col]
				if cell and not cell.captured and y <= cell.y + CELL_SIZE/2 and y >= cell.y - CELL_SIZE/2 then

					if cell.locked then
						local color = cell.lock_color
						if not color then
							print("‚ö†Ô∏è ERROR: Candado sin color en celda (" .. row .. "," .. col .. ")")
							return
						end

						if not self.collected_keys[color] then
							msg.post("hud", "show_message", { text = "üîí Necesit√°s la llave " .. color })
							return
						else
							cell.locked = false
							msg.post(cell.id, "unlock", {})
						end
					end
					
					if cell.sprite:sub(1, 4) == "key_" then
						local color = cell.sprite:match("^key_(.+)$") -- m√°s seguro que sub(5)

						if not color then
							print("‚ö†Ô∏è ERROR: No se pudo extraer color de sprite '" .. tostring(cell.sprite) .. "'")
							return
						end

						self.collected_keys[color] = true
						msg.post("hud", "show_message", { text = "üîì ¬°Llave " .. color .. " obtenida!" })

						timer.delay(0.01, false, function()
							for r = 0, GRID_ROWS - 1 do
								for c = 0, GRID_COLS - 1 do
									local target = self.grid[r][c]
									if target and target.locked and not target.captured and target.lock_color == color then
										target.locked = false
										msg.post(target.id, "unlock", {})
										return
									end
								end
							end
						end)
					end

					msg.post(cell.id, "capture")
					msg.post("claw", "object_grabbed", { object_sprite = cell.sprite ~= "bomb" and cell.sprite or nil })
					cell.captured = true

					for _, goal in ipairs(self.goals) do
						if goal.type == cell.sprite and goal.collected < goal.required then
							goal.collected = goal.collected + 1
							msg.post("hud", "update_goal", {
								type = goal.type,
								collected = goal.collected
							})
						end
					end

					local completed = true
					for _, goal in ipairs(self.goals) do
						if goal.collected < goal.required then
							completed = false
							break
						end
					end

					if completed and not self.game_over then
						self.game_over = true
						self.total_points = 0
						for _, goal in ipairs(self.goals) do
							self.total_points = self.total_points + goal.points_total
						end
						msg.post("panels#panels_gui", "level_completed", { points = self.total_points })
					elseif not self.game_over and check_impossible_goals(self) then
						self.game_over = true
						msg.post("panels#panels_gui", "level_failed")
					end

					self.remaining_drops = self.remaining_drops - 1
					msg.post("drops#drops", "set_drops", { drops = self.remaining_drops })

					if self.remaining_drops <= 0 and not self.game_over then
						self.game_over = true
						msg.post("panels#panels_gui", "level_failed")
					end

					break
				end
			end
		end

	elseif message_id == hash("consume_drop") then
		self.remaining_drops = self.remaining_drops - 1
		msg.post("drops#drops", "set_drops", { drops = self.remaining_drops })

		if self.remaining_drops <= 0 and not self.game_over then
			self.game_over = true
			msg.post("panels#panels_gui", "level_failed")
		end

	elseif message_id == hash("restart_level") then
		self.game_over = false
		self.total_points = 0
		self.has_key = false
		reset_grid(self)
		generate_goals_from_level(self)
		msg.post("claw#claw", "enable_touch")

	elseif message_id == hash("set_level") then
		self.level = message.level or 1
		self.has_key = false
		reset_grid(self)
		generate_goals_from_level(self)
		msg.post("claw#claw", "enable_touch")
	end
end
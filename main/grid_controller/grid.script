local CELL_SIZE = 100
local GRID_COLS = 5
local GRID_ROWS = 6

go.property("level", 1)

local POINTS = {
	bear_golden = 30,
	bear_blue = 15,
	bear_pink = 15,
	candy = 10,
	ball = 5,
	flip_flop = 5,
	box = 25,
	bomb = 0,
	bug = 0,
	rabbit = 30,
	fox = 35
}

local LEVELS = require("main.levels.levels")

local function explode_adjacent_cells(self, row, col)
	local directions = {
		{ d_row = -1, d_col = 0 }, { d_row = 1, d_col = 0 },
		{ d_row = 0, d_col = -1 }, { d_row = 0, d_col = 1 }
	}
	for _, dir in ipairs(directions) do
		local r, c = row + dir.d_row, col + dir.d_col
		if r >= 0 and r < GRID_ROWS and c >= 0 and c < GRID_COLS then
			local neighbor = self.grid[r][c]
			if neighbor and not neighbor.captured then
				msg.post(neighbor.id, "explode")
				neighbor.captured = true
			end
		end
	end
end

local function apply_level_movements(self)
	local movements = LEVELS[self.level].movements or {}
	for _, move in ipairs(movements) do
		local r, c = move.from_row - 1, move.from_col - 1
		local cell = self.grid[r] and self.grid[r][c]
		if cell and cell.id then
			msg.post(cell.id, "start_movement_loop", {
				x = move.to_x,
				y = move.to_y,
				loop = move.loop,
				wait = move.wait or 1.0,
				speed = move.speed or 0.5
			})
		end
	end
end

local function check_impossible_goals(self)
	local remaining = {}
	for row = 0, GRID_ROWS - 1 do
		for col = 0, GRID_COLS - 1 do
			local cell = self.grid[row][col]
			if cell and not cell.captured then
				local t = cell.sprite
				if POINTS[t] and POINTS[t] > 0 then
					remaining[t] = (remaining[t] or 0) + 1
				end
			end
		end
	end
	for _, goal in ipairs(self.goals) do
		if (remaining[goal.type] or 0) < (goal.required - goal.collected) then
			return true
		end
	end
	return false
end

local function generate_goals_from_level(self)
	local data = LEVELS[self.level]
	self.goals = {}
	for _, g in ipairs(data.goals) do
		table.insert(self.goals, {
			type = g.type,
			required = g.required,
			collected = 0,
			points_total = g.required * POINTS[g.type]
		})
	end
	print(" self.goals ",  self.goals )
	msg.post("hud", "init_goals", { goals = self.goals })
end

local function reset_grid(self)
	if self.creating_grid then
		print("â³ Ya se estÃ¡ creando la grilla, ignorando este llamado")
		return
	end
	self.creating_grid = true

	-- Eliminar celdas existentes
	for row = 0, GRID_ROWS - 1 do
		for col = 0, GRID_COLS - 1 do
			local cell = self.grid[row] and self.grid[row][col]
			if cell and cell.id and go.exists(cell.id) then
				msg.post(cell.id, "stop_particles")
				go.delete(cell.id)
			end
		end
	end

	self.grid = {}
	self.total_cells = 0

	timer.delay(0.05, false, function()
		local level_data = LEVELS[self.level]
		local layout = level_data and level_data.grid or {}
		local locked_cells = level_data.locked_cells or {}

		local start_x = -((GRID_COLS - 1) * CELL_SIZE) / 2
		local total_grid_height = CELL_SIZE * GRID_ROWS
		local start_y = (1280 / 2) - ((1280 - total_grid_height) / 2) - 100

		self.remaining_drops = level_data.max_drops or 5
		msg.post("drops#drops", "set_drops", { drops = self.remaining_drops })

		for row = 0, GRID_ROWS - 1 do
			self.grid[row] = {}
			for col = 0, GRID_COLS - 1 do
				local x = start_x + col * CELL_SIZE
				local y = start_y - row * CELL_SIZE
				local sprite_name = layout[row + 1] and layout[row + 1][col + 1]

				if sprite_name and sprite_name ~= "" then
					local id = factory.create("#cell_factory", vmath.vector3(x, y, 1))
					if id then
						-- Detectar si la celda estÃ¡ bloqueada por candado
						local locked = false
						local lock_color = nil
						for _, lock in ipairs(locked_cells) do
							if lock.row == row + 1 and lock.col == col + 1 then
								locked = true
								lock_color = lock.color
								break
							end
						end

						-- Guardar en la grilla
						self.grid[row][col] = {
							id = id,
							sprite = sprite_name,
							revealed = true,
							captured = false,
							locked = locked,
							lock_color = lock_color,
							x = x,
							y = y
						}
						self.total_cells = self.total_cells + 1

						-- Setear sprite y candado
						msg.post(id, "set_revealed_sprite", { sprite = sprite_name, row = row, col = col })
						if locked then
							msg.post(id, "set_locked", { color = lock_color })
						end

						-- AnimaciÃ³n de apariciÃ³n
						go.set_scale(vmath.vector3(0.01, 0.01, 1), id)
						local delay = (row * GRID_COLS + col) * 0.02
						timer.delay(delay, false, function()
							msg.post(id, "reveal")
							go.animate(id, "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(1, 1, 1), go.EASING_OUTBACK, 0.25)
						end)
					end
				end
			end
		end

		self.creating_grid = false
		apply_level_movements(self)
	end)
end


function init(self)
	self.grid = {}
	self.multiplier = 1
	self.total_points = 0
	self.game_over = false
	self.creating_grid = false
	self.collected_keys = {}
end

local function check_game_end(self)
	if self.game_over then return end

	-- âœ… Verificar si se completaron todos los objetivos
	local completed = true
	for _, goal in ipairs(self.goals) do
		if goal.collected < goal.required then
			completed = false
			break
		end
	end

	if completed then
		self.game_over = true
		self.total_points = 0
		for _, goal in ipairs(self.goals) do
			self.total_points = self.total_points + goal.points_total
		end
		print("ðŸŽ‰ VICTORIA: todos los objetivos cumplidos")
		msg.post("panels#panels_gui", "level_completed", {
			points = self.total_points,
			level = self.level
		})
		return
	end

	-- âŒ Verificar si ya es imposible completar los objetivos
	if check_impossible_goals(self) then
		self.game_over = true
		print("ðŸ’¥ DERROTA: objetivos imposibles de completar")
		msg.post("panels#panels_gui", "level_failed", {
			level = self.level,
			points = self.total_points
		})
		return
	end

	-- âŒ Verificar si se acabaron los drops sin haber cumplido los objetivos
	if self.remaining_drops <= 0 then
		self.game_over = true
		print("ðŸ’¥ DERROTA: sin drops restantes")
		msg.post("panels#panels_gui", "level_failed", {
			level = self.level,
			points = self.total_points
		})
	end
end


function on_message(self, message_id, message, sender)
	if message_id == hash("grab_object_at_column") then
		local x, y = message.x, message.y
		local MARGIN = CELL_SIZE * 0.5 
		local found = false

		for row = 0, GRID_ROWS - 1 do
			for col = 0, GRID_COLS - 1 do
				local cell = self.grid[row][col]
				if cell and not cell.captured then
					local pos = go.get_position(cell.id)
					local dx = math.abs(pos.x - x)
					local dy = math.abs(pos.y - y)

					if dx <= MARGIN and dy <= MARGIN then
						print(string.format("âœ… Captura encontrada en [%d,%d]", row, col))

						-- ðŸ”“ LÃ³gica de candado
						if cell.locked then
							local color = cell.lock_color
							if not color then
								print("âš ï¸ ERROR: Candado sin color")
								return
							end
							if not self.collected_keys[color] then
								msg.post("hud", "show_message", { text = "ðŸ”’ NecesitÃ¡s la llave " .. color })
								return
							else
								cell.locked = false
								msg.post(cell.id, "unlock", {})
							end
						end

						-- ðŸ—ï¸ LÃ³gica de llaves
						if cell.sprite:sub(1, 4) == "key_" then
							local color = cell.sprite:match("^key_(.+)$")
							if not color then
								print("âš ï¸ ERROR: No se pudo extraer color")
								return
							end

							self.collected_keys[color] = true
							msg.post("hud", "show_message", { text = "ðŸ”“ Â¡Llave " .. color .. " obtenida!" })

							timer.delay(0.01, false, function()
								for r = 0, GRID_ROWS - 1 do
									for c = 0, GRID_COLS - 1 do
										local target = self.grid[r][c]
										if target and target.locked and not target.captured and target.lock_color == color then
											target.locked = false
											msg.post(target.id, "unlock", {})
											return
										end
									end
								end
							end)
						end

						msg.post(cell.id, "capture")
						msg.post("claw", "object_grabbed", { object_sprite = cell.sprite ~= "bomb" and cell.sprite or nil })
						cell.captured = true

						-- Actualizar objetivos
						for _, goal in ipairs(self.goals) do
							if goal.type == cell.sprite and goal.collected < goal.required then
								goal.collected = goal.collected + 1
								msg.post("hud", "update_goal", {
									type = goal.type,
									collected = goal.collected
								})
							end
						end

						check_game_end(self)
						

						found = true
						break
					end
				end
			end
			if found then break end
		end
		
	elseif message_id == hash("consume_drop") then
		self.remaining_drops = self.remaining_drops - 1
		msg.post("drops#drops", "set_drops", { drops = self.remaining_drops })
		check_game_end(self)

	elseif message_id == hash("restart_level") then
		self.game_over = false
		self.total_points = 0
		self.has_key = false
		reset_grid(self)
		generate_goals_from_level(self)
		msg.post("claw#claw", "enable_touch")

	elseif message_id == hash("set_level") then
		self.level = message.level or 1
		self.has_key = false
		reset_grid(self)
		generate_goals_from_level(self)
		msg.post("claw#claw", "enable_touch")

	elseif message_id == hash("update_cell_position") then
		local cell = self.grid[message.row] and self.grid[message.row][message.col]
		if cell then
			cell.x = message.x
			cell.y = message.y
		end
	
	end
end
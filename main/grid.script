-- grid.script (actualizado para sincronizar nivel con victory_gui y usar LEVELS)

local CELL_SIZE = 90
local GRID_COLS = 5
local GRID_ROWS = 6

go.property("level", 1)

local POINTS = {
	bear_golden = 30,
	bear_blue = 15,
	bear_pink = 15,
	candy = 10,
	ball = 5,
	flip_flop = 5,
	box = 25,
	bomb = 0,
	bug = 0
}

local LEVELS = require("main.levels")

local function explode_adjacent_cells(self, row, col)
	local directions = {
		{ d_row = -1, d_col = 0 }, { d_row = 1, d_col = 0 },
		{ d_row = 0, d_col = -1 }, { d_row = 0, d_col = 1 }
	}
	for _, dir in ipairs(directions) do
		local r, c = row + dir.d_row, col + dir.d_col
		if r >= 0 and r < GRID_ROWS and c >= 0 and c < GRID_COLS then
			local neighbor = self.grid[r][c]
			if neighbor and not neighbor.captured then
				msg.post(neighbor.id, "explode")
				neighbor.captured = true
			end
		end
	end
end

local function check_impossible_goals(self)
	local remaining = {}
	for row = 0, GRID_ROWS - 1 do
		for col = 0, GRID_COLS - 1 do
			local cell = self.grid[row][col]
			if cell and not cell.captured then
				local t = cell.sprite
				if POINTS[t] and POINTS[t] > 0 then
					remaining[t] = (remaining[t] or 0) + 1
				end
			end
		end
	end
	for _, goal in ipairs(self.goals) do
		if (remaining[goal.type] or 0) < (goal.required - goal.collected) then
			return true
		end
	end
	return false
end

local function generate_goals_from_level(self)
	local data = LEVELS[self.level]
	self.goals = {}
	for _, g in ipairs(data.goals) do
		table.insert(self.goals, {
			type = g.type,
			required = g.required,
			collected = 0,
			points_total = g.required * POINTS[g.type]
		})
	end
	msg.post("hud", "init_goals", { goals = self.goals })
end

local function reset_grid(self)
	for row = 0, GRID_ROWS - 1 do
		for col = 0, GRID_COLS - 1 do
			local cell = self.grid[row] and self.grid[row][col]
			if cell and cell.id then
				go.delete(cell.id)
			end
		end
	end

	self.grid = {}
	self.total_cells = 0

	timer.delay(0.05, false, function()
		local level_data = LEVELS[self.level]
		local layout = level_data and level_data.grid or {}
		local start_x = -((GRID_COLS - 1) * CELL_SIZE) / 2
		local start_y = ((GRID_ROWS - 1) * CELL_SIZE) / 2 - 80

		for row = 0, GRID_ROWS - 1 do
			self.grid[row] = {}
			for col = 0, GRID_COLS - 1 do
				local x = start_x + col * CELL_SIZE
				local y = start_y - row * CELL_SIZE
				local id = factory.create("#cell_factory", vmath.vector3(x, y, 1))
				if id then
					local sprite_name = layout[row + 1] and layout[row + 1][col + 1] or "bear_pink"
					self.grid[row][col] = {
						id = id,
						sprite = sprite_name,
						revealed = true,
						captured = false,
						x = x,
						y = y
					}
					self.total_cells = self.total_cells + 1
					msg.post(id, "set_revealed_sprite", { sprite = sprite_name, row = row, col = col })
					msg.post(id, "reveal")
				else
					print(string.format("⚠️ No se pudo crear celda en fila %d, columna %d", row, col))
				end
			end
		end
	end)
end

function init(self)
	self.grid = {}
	self.multiplier = 1
	self.total_points = 0
	self.game_over = false
	msg.post("victory_panel#victory_gui", "set_level", { level = self.level })
	reset_grid(self)
	generate_goals_from_level(self)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("grab_object_at_column") then
		local x, y = message.x, message.y
		local start_x = -((GRID_COLS - 1) * CELL_SIZE) / 2
		local col = math.floor((x - start_x + CELL_SIZE/2) / CELL_SIZE)

		if col >= 0 and col < GRID_COLS then
			for row = 0, GRID_ROWS - 1 do
				local cell = self.grid[row][col]
				if cell and not cell.captured and y <= cell.y + CELL_SIZE/2 and y >= cell.y - CELL_SIZE/2 then
					msg.post(cell.id, "capture")
					msg.post("claw", "object_grabbed", { object_sprite = cell.sprite ~= "bomb" and cell.sprite or nil })
					msg.post("points", "add_points", { points = POINTS[cell.sprite] or 0 })
					cell.captured = true

					for _, goal in ipairs(self.goals) do
						if goal.type == cell.sprite and goal.collected < goal.required then
							goal.collected = goal.collected + 1
							msg.post("hud", "update_goal", {
								type = goal.type,
								collected = goal.collected
							})
						end
					end

					local completed = true
					for _, goal in ipairs(self.goals) do
						if goal.collected < goal.required then
							completed = false
							break
						end
					end

					if completed and not self.game_over then
						self.game_over = true
						self.total_points = 0
						for _, goal in ipairs(self.goals) do
							self.total_points = self.total_points + goal.points_total
						end
						msg.post("hud", "level_completed", { points = self.total_points })
					elseif not self.game_over and check_impossible_goals(self) then
						self.game_over = true
						msg.post("hud", "level_failed")
					end

					break
				end
			end
		end

	elseif message_id == hash("restart_level") then
		self.game_over = false
		self.total_points = 0
		reset_grid(self)
		generate_goals_from_level(self)
		msg.post("victory_panel#victory_gui", "disable")
		msg.post("claw#claw", "enable_touch")
		msg.post("victory_panel#victory_gui", "set_level", { level = self.level })

	elseif message_id == hash("set_level") then
		self.level = message.level or 1
		msg.post("victory_panel#victory_gui", "set_level", { level = self.level })
	end
end
